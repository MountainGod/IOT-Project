/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/faceLandmarks.js":
/*!*****************************!*\
  !*** ./js/faceLandmarks.js ***!
  \*****************************/
/***/ (() => {

eval("const resultText = document.getElementById(\"resultText\");\r\nconst canvas     = document.getElementById(\"streamCanvas\");\r\nconst img        = document.getElementById(\"camStream\");\r\nconst video      = document.getElementById(\"videoStream\");\r\nconst ctx        = canvas.getContext(\"2d\");\r\n\r\nlet model;\r\nlet stopFlag         = false;\r\nlet measuredDistance = -1;\r\nconst FPS            = 1000 / 30; // 30 FPS in ms\r\n\r\n/**\r\n * Calculates the real-world distance of two facial landmarks.\r\n * @param x first landmark\r\n * @param y second landmark\r\n * @returns {number} the distance between the landmarks in centimeters\r\n */\r\nfunction getDistanceInCM(x, y) {\r\n\treturn Math.hypot(x, y) / 6;\r\n}\r\n\r\n/**\r\n * Loads the MediaPipe face landmark model, with a max of 1 face.\r\n * @returns {Promise<*>} fulfills when the model is done loading.\r\n */\r\nasync function loadFaceLandmarkDetectionModel() {\r\n\treturn faceLandmarksDetection\r\n\t.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,\r\n\t      {maxFaces: 1});\r\n}\r\n\r\n/**\r\n * Uses the face landmark model to get the position of the upper and lower lip landmark.\r\n * After calculating the distance, it writes it to the resultText element.\r\n * @returns {Promise<void>} ignore\r\n */\r\nasync function calculateDistance() {\r\n\tconst predictions = await model.estimateFaces({\r\n\t\t                                              input:          video,\r\n\t\t                                              returnTensors:  false,\r\n\t\t                                              flipHorizontal: false,\r\n\t\t                                              predictIrises:  false,\r\n\t                                              });\r\n\t\r\n\tif (predictions.length > 0) {\r\n\t\tpredictions.forEach(prediction => {\r\n\t\t\tconst keyPoints = prediction.mesh; // 13 and 14 are the relevant ones, with 13 being the top lip\r\n\t\t\tconst UPPER_LIP = 13;\r\n\t\t\tconst LOWER_LIP = 14;\r\n\t\t\t\r\n\t\t\tmeasuredDistance       = getDistanceInCM(\r\n\t\t\t\tkeyPoints[UPPER_LIP][0] - keyPoints[LOWER_LIP][0],\r\n\t\t\t\tkeyPoints[UPPER_LIP][1] - keyPoints[LOWER_LIP][1],\r\n\t\t\t);\r\n\t\t\t// convert floating point number to rounded string\r\n\t\t\tresultText.textContent = (+measuredDistance.toFixed(1)).toString();\r\n\t\t});\r\n\t}\r\n\t\r\n\tif (stopFlag) {\r\n\t\tstopFlag = false;\r\n\t}\r\n\telse {\r\n\t\tsetTimeout(calculateDistance, FPS);\r\n\t}\r\n}\r\n\r\n// Modal code\r\nconst closeModalBtn   = document.getElementById(\"closeModalBtn\");\r\nconst startPredictBtn = document.getElementById(\"startPredictBtn\");\r\nconst stopPredictBtn  = document.getElementById(\"stopPredictBtn\");\r\n\r\n// Make Canvas show the camera stream\r\nvideo.addEventListener(\"playing\", function () {\r\n\tlet canvasParentH, canvasParentW, canvasH, canvasW;\r\n\t\r\n\t// original video aspect ratio\r\n\tlet vidRatio        = video.videoWidth / video.videoHeight;\r\n\tlet vidReverseRatio = 1 / vidRatio;\r\n\t\r\n\tlet $this = this; //cache\r\n\t(function loop() {\r\n\t\tif (!$this.paused && !$this.ended) {\r\n\t\t\t// The maximum area the canvas can expand\r\n\t\t\tcanvasParentH = canvas.parentElement.clientHeight;\r\n\t\t\tcanvasParentW = canvas.parentElement.clientWidth;\r\n\t\t\t\r\n\t\t\t// Calculate how much the canvas can expand while keeping the original aspect ratio\r\n\t\t\tif (canvasParentW * vidReverseRatio > canvasParentH) {\r\n\t\t\t\tcanvasW = canvasParentH * vidRatio;\r\n\t\t\t\tcanvasH = canvasParentH;\r\n\t\t\t}\r\n\t\t\telse if (canvasParentH * vidRatio > canvasParentW) {\r\n\t\t\t\tcanvasH = canvasParentW * vidReverseRatio;\r\n\t\t\t\tcanvasW = canvasParentW;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcanvasW = canvasParentW;\r\n\t\t\t\tcanvasH = canvasParentH;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Set canvas dimensions\r\n\t\t\tcanvas.style.height = `${canvasH}px`;\r\n\t\t\tcanvas.style.width  = `${canvasW}px`;\r\n\t\t\tcanvas.height       = canvasH;\r\n\t\t\tcanvas.width        = canvasW;\r\n\t\t\t\r\n\t\t\tctx.drawImage($this, 0, 0, canvas.clientWidth, canvas.clientHeight);\r\n\t\t\t\r\n\t\t\tsetTimeout(loop, FPS); // Drawing at the desired FPS\r\n\t\t}\r\n\t})();\r\n});\r\nstartPredictBtn.addEventListener(\"click\", async () => {\r\n\tmodel = await loadFaceLandmarkDetectionModel();\r\n\tcalculateDistance();\r\n\t\r\n\tstopPredictBtn.hidden  = false;\r\n\tstartPredictBtn.hidden = true;\r\n});\r\n\r\nstopPredictBtn.addEventListener(\"click\", () => {\r\n\tstopFlag               = true;\r\n\tstopPredictBtn.hidden  = true;\r\n\tstartPredictBtn.hidden = false;\r\n\t\r\n});\r\n\r\ncloseModalBtn.addEventListener(\"click\", () => {\r\n\tstopFlag               = true;\r\n\tstopPredictBtn.hidden  = true;\r\n\tstartPredictBtn.hidden = false;\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9mYWNlTGFuZG1hcmtzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxFQUFFO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pb3QtcHJvamVjdC8uL2pzL2ZhY2VMYW5kbWFya3MuanM/YTgxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZXN1bHRUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXN1bHRUZXh0XCIpO1xyXG5jb25zdCBjYW52YXMgICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdHJlYW1DYW52YXNcIik7XHJcbmNvbnN0IGltZyAgICAgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbVN0cmVhbVwiKTtcclxuY29uc3QgdmlkZW8gICAgICA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW9TdHJlYW1cIik7XHJcbmNvbnN0IGN0eCAgICAgICAgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxubGV0IG1vZGVsO1xyXG5sZXQgc3RvcEZsYWcgICAgICAgICA9IGZhbHNlO1xyXG5sZXQgbWVhc3VyZWREaXN0YW5jZSA9IC0xO1xyXG5jb25zdCBGUFMgICAgICAgICAgICA9IDEwMDAgLyAzMDsgLy8gMzAgRlBTIGluIG1zXHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgcmVhbC13b3JsZCBkaXN0YW5jZSBvZiB0d28gZmFjaWFsIGxhbmRtYXJrcy5cclxuICogQHBhcmFtIHggZmlyc3QgbGFuZG1hcmtcclxuICogQHBhcmFtIHkgc2Vjb25kIGxhbmRtYXJrXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsYW5kbWFya3MgaW4gY2VudGltZXRlcnNcclxuICovXHJcbmZ1bmN0aW9uIGdldERpc3RhbmNlSW5DTSh4LCB5KSB7XHJcblx0cmV0dXJuIE1hdGguaHlwb3QoeCwgeSkgLyA2O1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZHMgdGhlIE1lZGlhUGlwZSBmYWNlIGxhbmRtYXJrIG1vZGVsLCB3aXRoIGEgbWF4IG9mIDEgZmFjZS5cclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IGZ1bGZpbGxzIHdoZW4gdGhlIG1vZGVsIGlzIGRvbmUgbG9hZGluZy5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvYWRGYWNlTGFuZG1hcmtEZXRlY3Rpb25Nb2RlbCgpIHtcclxuXHRyZXR1cm4gZmFjZUxhbmRtYXJrc0RldGVjdGlvblxyXG5cdC5sb2FkKGZhY2VMYW5kbWFya3NEZXRlY3Rpb24uU3VwcG9ydGVkUGFja2FnZXMubWVkaWFwaXBlRmFjZW1lc2gsXHJcblx0ICAgICAge21heEZhY2VzOiAxfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VzIHRoZSBmYWNlIGxhbmRtYXJrIG1vZGVsIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIHVwcGVyIGFuZCBsb3dlciBsaXAgbGFuZG1hcmsuXHJcbiAqIEFmdGVyIGNhbGN1bGF0aW5nIHRoZSBkaXN0YW5jZSwgaXQgd3JpdGVzIGl0IHRvIHRoZSByZXN1bHRUZXh0IGVsZW1lbnQuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBpZ25vcmVcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKCkge1xyXG5cdGNvbnN0IHByZWRpY3Rpb25zID0gYXdhaXQgbW9kZWwuZXN0aW1hdGVGYWNlcyh7XHJcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICAgICAgICAgIHZpZGVvLFxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblRlbnNvcnM6ICBmYWxzZSxcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGlwSG9yaXpvbnRhbDogZmFsc2UsXHJcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZGljdElyaXNlczogIGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHRcclxuXHRpZiAocHJlZGljdGlvbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0cHJlZGljdGlvbnMuZm9yRWFjaChwcmVkaWN0aW9uID0+IHtcclxuXHRcdFx0Y29uc3Qga2V5UG9pbnRzID0gcHJlZGljdGlvbi5tZXNoOyAvLyAxMyBhbmQgMTQgYXJlIHRoZSByZWxldmFudCBvbmVzLCB3aXRoIDEzIGJlaW5nIHRoZSB0b3AgbGlwXHJcblx0XHRcdGNvbnN0IFVQUEVSX0xJUCA9IDEzO1xyXG5cdFx0XHRjb25zdCBMT1dFUl9MSVAgPSAxNDtcclxuXHRcdFx0XHJcblx0XHRcdG1lYXN1cmVkRGlzdGFuY2UgICAgICAgPSBnZXREaXN0YW5jZUluQ00oXHJcblx0XHRcdFx0a2V5UG9pbnRzW1VQUEVSX0xJUF1bMF0gLSBrZXlQb2ludHNbTE9XRVJfTElQXVswXSxcclxuXHRcdFx0XHRrZXlQb2ludHNbVVBQRVJfTElQXVsxXSAtIGtleVBvaW50c1tMT1dFUl9MSVBdWzFdLFxyXG5cdFx0XHQpO1xyXG5cdFx0XHQvLyBjb252ZXJ0IGZsb2F0aW5nIHBvaW50IG51bWJlciB0byByb3VuZGVkIHN0cmluZ1xyXG5cdFx0XHRyZXN1bHRUZXh0LnRleHRDb250ZW50ID0gKCttZWFzdXJlZERpc3RhbmNlLnRvRml4ZWQoMSkpLnRvU3RyaW5nKCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0XHJcblx0aWYgKHN0b3BGbGFnKSB7XHJcblx0XHRzdG9wRmxhZyA9IGZhbHNlO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHNldFRpbWVvdXQoY2FsY3VsYXRlRGlzdGFuY2UsIEZQUyk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBNb2RhbCBjb2RlXHJcbmNvbnN0IGNsb3NlTW9kYWxCdG4gICA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2xvc2VNb2RhbEJ0blwiKTtcclxuY29uc3Qgc3RhcnRQcmVkaWN0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGFydFByZWRpY3RCdG5cIik7XHJcbmNvbnN0IHN0b3BQcmVkaWN0QnRuICA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RvcFByZWRpY3RCdG5cIik7XHJcblxyXG4vLyBNYWtlIENhbnZhcyBzaG93IHRoZSBjYW1lcmEgc3RyZWFtXHJcbnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIGZ1bmN0aW9uICgpIHtcclxuXHRsZXQgY2FudmFzUGFyZW50SCwgY2FudmFzUGFyZW50VywgY2FudmFzSCwgY2FudmFzVztcclxuXHRcclxuXHQvLyBvcmlnaW5hbCB2aWRlbyBhc3BlY3QgcmF0aW9cclxuXHRsZXQgdmlkUmF0aW8gICAgICAgID0gdmlkZW8udmlkZW9XaWR0aCAvIHZpZGVvLnZpZGVvSGVpZ2h0O1xyXG5cdGxldCB2aWRSZXZlcnNlUmF0aW8gPSAxIC8gdmlkUmF0aW87XHJcblx0XHJcblx0bGV0ICR0aGlzID0gdGhpczsgLy9jYWNoZVxyXG5cdChmdW5jdGlvbiBsb29wKCkge1xyXG5cdFx0aWYgKCEkdGhpcy5wYXVzZWQgJiYgISR0aGlzLmVuZGVkKSB7XHJcblx0XHRcdC8vIFRoZSBtYXhpbXVtIGFyZWEgdGhlIGNhbnZhcyBjYW4gZXhwYW5kXHJcblx0XHRcdGNhbnZhc1BhcmVudEggPSBjYW52YXMucGFyZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcblx0XHRcdGNhbnZhc1BhcmVudFcgPSBjYW52YXMucGFyZW50RWxlbWVudC5jbGllbnRXaWR0aDtcclxuXHRcdFx0XHJcblx0XHRcdC8vIENhbGN1bGF0ZSBob3cgbXVjaCB0aGUgY2FudmFzIGNhbiBleHBhbmQgd2hpbGUga2VlcGluZyB0aGUgb3JpZ2luYWwgYXNwZWN0IHJhdGlvXHJcblx0XHRcdGlmIChjYW52YXNQYXJlbnRXICogdmlkUmV2ZXJzZVJhdGlvID4gY2FudmFzUGFyZW50SCkge1xyXG5cdFx0XHRcdGNhbnZhc1cgPSBjYW52YXNQYXJlbnRIICogdmlkUmF0aW87XHJcblx0XHRcdFx0Y2FudmFzSCA9IGNhbnZhc1BhcmVudEg7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoY2FudmFzUGFyZW50SCAqIHZpZFJhdGlvID4gY2FudmFzUGFyZW50Vykge1xyXG5cdFx0XHRcdGNhbnZhc0ggPSBjYW52YXNQYXJlbnRXICogdmlkUmV2ZXJzZVJhdGlvO1xyXG5cdFx0XHRcdGNhbnZhc1cgPSBjYW52YXNQYXJlbnRXO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGNhbnZhc1cgPSBjYW52YXNQYXJlbnRXO1xyXG5cdFx0XHRcdGNhbnZhc0ggPSBjYW52YXNQYXJlbnRIO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnNcclxuXHRcdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NhbnZhc0h9cHhgO1xyXG5cdFx0XHRjYW52YXMuc3R5bGUud2lkdGggID0gYCR7Y2FudmFzV31weGA7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgICAgICAgPSBjYW52YXNIO1xyXG5cdFx0XHRjYW52YXMud2lkdGggICAgICAgID0gY2FudmFzVztcclxuXHRcdFx0XHJcblx0XHRcdGN0eC5kcmF3SW1hZ2UoJHRoaXMsIDAsIDAsIGNhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzLmNsaWVudEhlaWdodCk7XHJcblx0XHRcdFxyXG5cdFx0XHRzZXRUaW1lb3V0KGxvb3AsIEZQUyk7IC8vIERyYXdpbmcgYXQgdGhlIGRlc2lyZWQgRlBTXHJcblx0XHR9XHJcblx0fSkoKTtcclxufSk7XHJcbnN0YXJ0UHJlZGljdEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xyXG5cdG1vZGVsID0gYXdhaXQgbG9hZEZhY2VMYW5kbWFya0RldGVjdGlvbk1vZGVsKCk7XHJcblx0Y2FsY3VsYXRlRGlzdGFuY2UoKTtcclxuXHRcclxuXHRzdG9wUHJlZGljdEJ0bi5oaWRkZW4gID0gZmFsc2U7XHJcblx0c3RhcnRQcmVkaWN0QnRuLmhpZGRlbiA9IHRydWU7XHJcbn0pO1xyXG5cclxuc3RvcFByZWRpY3RCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcclxuXHRzdG9wRmxhZyAgICAgICAgICAgICAgID0gdHJ1ZTtcclxuXHRzdG9wUHJlZGljdEJ0bi5oaWRkZW4gID0gdHJ1ZTtcclxuXHRzdGFydFByZWRpY3RCdG4uaGlkZGVuID0gZmFsc2U7XHJcblx0XHJcbn0pO1xyXG5cclxuY2xvc2VNb2RhbEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG5cdHN0b3BGbGFnICAgICAgICAgICAgICAgPSB0cnVlO1xyXG5cdHN0b3BQcmVkaWN0QnRuLmhpZGRlbiAgPSB0cnVlO1xyXG5cdHN0YXJ0UHJlZGljdEJ0bi5oaWRkZW4gPSBmYWxzZTtcclxufSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/faceLandmarks.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/faceLandmarks.js"]();
/******/ 	
/******/ })()
;